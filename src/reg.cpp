// handle alias registry stuff
#include "inc/reg.h"

#include <iostream>

// AliasGroup defs
AliasGroup::AliasGroup() {}
AliasGroup::AliasGroup(std::deque<uint8_t>& data)
{
    try
    {
        load(data);
    }
    catch(...)
    {
        throw;
    }
}
void AliasGroup::load(std::deque<uint8_t>& data)
{
    try
    {
        uint8_t num_subels = dq_getpop(data); // includes both subgroups and (sub)aliases
        while(num_subels--)
        {
            // read through subels (cse = current sub element)
            // get subel type (1B), 1 --> alias, 2 --> group
            uint8_t cse_type = dq_getpop(data);
            if(cse_type == 1)
            {
                std::string alias = "";
                std::string path = "";

                // load alias until \0
                uint8_t ch;
                while(dq_getpop(data, &ch))
                    alias += (char)ch;

                // load path until \0
                while(dq_getpop(data, &ch))
                    path += (char)ch;

                // stick in map
                aliases[alias] = path;
            }
            else if(cse_type == 2)
            {
                // load name until \0
                std::string grp_name = "";
                uint8_t ch;
                while(dq_getpop(data, &ch))
                    grp_name += (char)ch;

                // create subgroup, pass datastream to it
                subgroups[grp_name] = AliasGroup(data);
            }
            else
            {
                throw CAERR("invalid data");
            }
        }
    }
    catch(CAError&) // will be generated by us
    {
        throw;
    }
    catch(...) // will be generated by stl, probably
    {
        throw CAERR("invalid data");
    }
}
std::string AliasGroup::get_path(std::deque<std::string>& alias_accession) const
{
    try
    {
        if(alias_accession.size() == 1)
            return aliases[alias_accession.front()];
        else
            return subgroups[dq_getpop(alias_accession)].get_path(alias_accession);
    }
    catch(...)
    {
        throw CAERR("invalid alias");
    }
}
void AliasGroup::add_group(std::deque<std::string>& group)
{
    try
    {
        if(group.size() == 1)
            subgroups[group.front()] = AliasGroup();
        else
            subgroups[dq_getpop(group)].add_group(group);
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        raise CAERR("failed to add group");
    }
}
void AliasGroup::remove_group(std::deque<std::string>& group)
{
    try
    {
        if(group.size() == 1)
            subgroups.erase(group.front());
        else
            subgroups[dq_getpop(group)].remove_group(group);
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        raise CAERR("failed to remove group");
    }
}
void AliasGroup::add_alias(std::deque<std::string>& alias, const std::string& path)
{
    try
    {
        if(alias.size() == 1)
            aliases[alias.front()] = path;
        else
            subgroups[dq_getpop(alias)].add_alias(alias);
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        raise CAERR("failed to add alias");
    }
}
void AliasGroup::remove_alias(std::deque<std::string>& alias)
{
    try
    {
        if(alias.size() == 1)
            aliases.erase(alias.front());
        else
            subgroups[dq_getpop(alias)].remove_alias(alias);
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        raise CAERR("failed to remove alias");
    }
}

// AliasRegistry defs
AliasRegistry::AliasRegistry()
{
    changed = false;
}
AliasRegistry::AliasRegistry(const std::string& path)
{
    try
    {
        changed = false;
        load(path);
    }
    catch(...)
    {
        throw;
    }
}
void AliasRegistry::load(const std::string& path)
{
    std::deque<uint8_t> data;

    // open file
    std::ifstream fin(path, std::ios::bin | std::ios::in);
    if(!fin)
        throw CAERR("could not open registry");

    // read file
    char ch;
    fin.get(ch);
    while(fin)
    {
        data.push_back((uint8_t)ch);
        fin.get(ch);
    }
    fin.close();

    // load as top group using inherited data processing func
    try
    {
        load(data);
    }
    catch(...) // everything should be std::string
    {
        throw;
    }
}
std::string AliasRegistry::get_path(const std::string& alias_accession) const
{
    try
    {
        if(alias_accession[0] == ':')
            return aliases[alias_accession.substr(1)];
        else
        {
            auto split = split_str(alias_accession, ':');
            std::deque<std::string> new_aa(split.begin(), split.end());
            return get_path(new_aa);
        }
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        throw CAERR("invalid alias");
    }
}

void AliasRegistry::add_group(const std::string& name)
{
    try
    {
        auto split = split_str(name, ':');
        std::deque<std::string> group_accession(split.begin(), split.end());
        add_group(group_accession);
        changed = true;
    }
    catch(...)
    {
        throw;
    }
}
void AliasRegistry::remove_group(const std::string& name)
{
    try
    {
        auto split = split_str(name, ':');
        std::deque<std::string> group_accession(split.begin(), split.end());
        remove_group(group_accession);
        changed = true;
    }
    catch(...)
    {
        throw;
    }
}
void AliasRegistry::add_alias(const std::string& name, const std::string& path)
{
    try
    {
        if(name[0] == ':')
            aliases[name.substr(1)] = path;
        else
        {
            auto split = split_str(name, ':');
            std::deque<std::string> alias_accession(split.begin(), split.end());
            add_alias(alias_accession, path);
        }
        changed = true;
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        throw CAERR("failed to add alias");
    }
}
void AliasRegistry::remove_alias(const std::string& name)
{
    try
    {
        if(name[0] == ':')
            aliases.erase(name.substr(1));
        else
        {
            auto split = split_str(name, ':');
            std::deque<std::string> alias_accession(split.begin(), split.end());
            remove_alias(alias_accession);
        }
        changed = true;
    }
    catch(CAError&)
    {
        throw;
    }
    catch(...)
    {
        throw CAERR("failed to add alias");
    }
}
void AliasRegistry::save(const std::string& path) const
{
    if(!changed)
        return;
    // TODO
}

/////////////////
void print_alias_management_help(std::ostream& dest)
{
    dest
        << "usage: cy-alias a <sub-command> [options]\n"
        << "details:\n"
        << "\tsub-command\tthe sub-sub-command passed to cy-alias a\n"
        << "\t\thelp|h\tprint help\n"
        << "\t\tadd|a\tadd alias or group\n"
        << "\t\trem|r\tremove alias or group\n"
        << "\t\tlist|l\tlist alias tree structure\n";
}

#define INV_A_USAGE(spec) \
    {log_err("invalid usage of 'a' command");\
    print_alias_management_help(std::cerr);\
    throw CAERR(spec);}
#define T_INV_A_USAGE(exp, spec) \
    if(exp) INV_A_USAGE(spec)

void cmd_manage_aliases(const std::vector<std::string>& params, AliasRegistry& alias_reg)
{
    T_INV_A_USAGE(params.empty(), "not enough arguments");

    std::string subcmd = params[0];
    if(subcmd == "help" || subcmd == "h")
    {
        print_alias_management_help(std::cout);
    }
    else if(subcmd == "add" || subcmd == "a")
    {
        T_INV_A_USAGE(params.size() < 3, "not enough arguments");

        std::string type = params[1];
        if(type == "alias" || type == "a")
        {
            T_INV_A_USAGE(params.size() < 4, "not enough arguments");
            T_INV_A_USAGE(params.size()%2 != 0, "invalid usage");

            for(int curr = 2; curr < params.size(); curr += 2)
            {
                try
                {
                    alias_reg.add_alias(params[curr], params[curr+1]);
                }
                catch(...)
                {
                    throw;
                }
            }
        }
        else if(type == "group" || type == "g")
        {
            for(int curr = 2; curr < params.size(); curr++)
            {
                try
                {
                    alias_reg.add_group(params[curr]);
                }
                catch(...)
                {
                    throw;
                }
            }
        }
        else
        {
            INV_A_USAGE(("type '" + type + "' not recognized"));
        }
    }
    else if(subcmd == "rem" || subcmd == "r")
    {
        T_INV_A_USAGE(params.size() < 3, "not enough arguments");

        std::string type = params[1];
        if(type == "alias" || type == "a")
        {
            for(int curr = 2; curr < params.size(); curr++)
            {
                try
                {
                    alias_reg.remove_alias(params[curr]);
                }
                catch(...)
                {
                    throw;
                }
            }
        }
        else if(type == "group" || type == "g")
        {
            for(int curr = 2; curr < params.size(); curr++)
            {
                try
                {
                    alias_reg.remove_group(params[curr]);
                }
                catch(...)
                {
                    throw;
                }
            }
        }
        else
        {
            INV_A_USAGE(("type '" + type + "' not recognized"));
        }
    }
    else if(subcmd == "list" || subcmd == "l")
    {
        //TODO
        throw CAERR("list function not yet supported D:");
    }
    else
    {
        INV_A_USAGE(("sub-sub-command '" + subcmd + "' not recognized"))
    }

    alias_reg.save();
}
